// Package SirikitCloudMedia provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.3 DO NOT EDIT.
package SirikitCloudMedia

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for AddMediaIntentResponseCode.
const (
	AddMediaIntentResponseCodeFailure AddMediaIntentResponseCode = "failure"

	AddMediaIntentResponseCodeFailureRequiringAppLaunch AddMediaIntentResponseCode = "failureRequiringAppLaunch"

	AddMediaIntentResponseCodeInProgress AddMediaIntentResponseCode = "inProgress"

	AddMediaIntentResponseCodeReady AddMediaIntentResponseCode = "ready"

	AddMediaIntentResponseCodeSuccess AddMediaIntentResponseCode = "success"

	AddMediaIntentResponseCodeUnspecified AddMediaIntentResponseCode = "unspecified"
)

// Defines values for AddMediaMediaDestinationUnsupportedReason.
const (
	AddMediaMediaDestinationUnsupportedReasonPlaylistNameNotFound AddMediaMediaDestinationUnsupportedReason = "playlistNameNotFound"

	AddMediaMediaDestinationUnsupportedReasonPlaylistNotEditable AddMediaMediaDestinationUnsupportedReason = "playlistNotEditable"
)

// Defines values for AddMediaMediaItemUnsupportedReason.
const (
	AddMediaMediaItemUnsupportedReasonExplicitContentSettings AddMediaMediaItemUnsupportedReason = "explicitContentSettings"

	AddMediaMediaItemUnsupportedReasonLoginRequired AddMediaMediaItemUnsupportedReason = "loginRequired"

	AddMediaMediaItemUnsupportedReasonRegionRestriction AddMediaMediaItemUnsupportedReason = "regionRestriction"

	AddMediaMediaItemUnsupportedReasonRestrictedContent AddMediaMediaItemUnsupportedReason = "restrictedContent"

	AddMediaMediaItemUnsupportedReasonSubscriptionRequired AddMediaMediaItemUnsupportedReason = "subscriptionRequired"

	AddMediaMediaItemUnsupportedReasonUnsupportedMediaType AddMediaMediaItemUnsupportedReason = "unsupportedMediaType"
)

// Defines values for MediaAffinityType.
const (
	MediaAffinityTypeDislike MediaAffinityType = "dislike"

	MediaAffinityTypeLike MediaAffinityType = "like"

	MediaAffinityTypeUnknown MediaAffinityType = "unknown"
)

// Defines values for MediaDestinationMediaDestinationType.
const (
	MediaDestinationMediaDestinationTypeLibrary MediaDestinationMediaDestinationType = "library"

	MediaDestinationMediaDestinationTypePlaylist MediaDestinationMediaDestinationType = "playlist"
)

// Defines values for MediaItemType.
const (
	MediaItemTypeAlbum MediaItemType = "album"

	MediaItemTypeAlgorithmicRadioStation MediaItemType = "algorithmicRadioStation"

	MediaItemTypeArtist MediaItemType = "artist"

	MediaItemTypeAudioBook MediaItemType = "audioBook"

	MediaItemTypeGenre MediaItemType = "genre"

	MediaItemTypeMovie MediaItemType = "movie"

	MediaItemTypeMusic MediaItemType = "music"

	MediaItemTypeMusicStation MediaItemType = "musicStation"

	MediaItemTypeMusicVideo MediaItemType = "musicVideo"

	MediaItemTypeNews MediaItemType = "news"

	MediaItemTypePlaylist MediaItemType = "playlist"

	MediaItemTypePodcastEpisode MediaItemType = "podcastEpisode"

	MediaItemTypePodcastPlaylist MediaItemType = "podcastPlaylist"

	MediaItemTypePodcastShow MediaItemType = "podcastShow"

	MediaItemTypePodcastStation MediaItemType = "podcastStation"

	MediaItemTypeRadioStation MediaItemType = "radioStation"

	MediaItemTypeSong MediaItemType = "song"

	MediaItemTypeStation MediaItemType = "station"

	MediaItemTypeTvShow MediaItemType = "tvShow"

	MediaItemTypeTvShowEpisode MediaItemType = "tvShowEpisode"

	MediaItemTypeUnknown MediaItemType = "unknown"
)

// Defines values for MediaReference.
const (
	MediaReferenceCurrentlyPlaying MediaReference = "currentlyPlaying"

	MediaReferenceMy MediaReference = "my"

	MediaReferenceUnknown MediaReference = "unknown"
)

// Defines values for MediaSortOrder.
const (
	MediaSortOrderBest MediaSortOrder = "best"

	MediaSortOrderNewest MediaSortOrder = "newest"

	MediaSortOrderOldest MediaSortOrder = "oldest"

	MediaSortOrderPopular MediaSortOrder = "popular"

	MediaSortOrderRecommended MediaSortOrder = "recommended"

	MediaSortOrderTrending MediaSortOrder = "trending"

	MediaSortOrderUnknown MediaSortOrder = "unknown"

	MediaSortOrderUnpopular MediaSortOrder = "unpopular"

	MediaSortOrderWorst MediaSortOrder = "worst"
)

// Defines values for PlayMediaControlScheme.
const (
	PlayMediaControlSchemeAdvertisement PlayMediaControlScheme = "advertisement"

	PlayMediaControlSchemeAudioBook PlayMediaControlScheme = "audioBook"

	PlayMediaControlSchemeCustom PlayMediaControlScheme = "custom"

	PlayMediaControlSchemeInternetRadio PlayMediaControlScheme = "internetRadio"

	PlayMediaControlSchemeLiveStreaming PlayMediaControlScheme = "liveStreaming"

	PlayMediaControlSchemeOnDemand PlayMediaControlScheme = "onDemand"

	PlayMediaControlSchemePodcast PlayMediaControlScheme = "podcast"
)

// Defines values for PlayMediaIntentResponseCode.
const (
	PlayMediaIntentResponseCodeFailure PlayMediaIntentResponseCode = "failure"

	PlayMediaIntentResponseCodeFailureNoUnplayedContent PlayMediaIntentResponseCode = "failureNoUnplayedContent"

	PlayMediaIntentResponseCodeFailureRequiringAppLaunch PlayMediaIntentResponseCode = "failureRequiringAppLaunch"

	PlayMediaIntentResponseCodeFailureRestrictedContent PlayMediaIntentResponseCode = "failureRestrictedContent"

	PlayMediaIntentResponseCodeFailureUnknownMediaType PlayMediaIntentResponseCode = "failureUnknownMediaType"

	PlayMediaIntentResponseCodeSuccess PlayMediaIntentResponseCode = "success"

	PlayMediaIntentResponseCodeUnspecified PlayMediaIntentResponseCode = "unspecified"
)

// Defines values for PlayMediaMediaItemUnsupportedReason.
const (
	PlayMediaMediaItemUnsupportedReasonExplicitContentSettings PlayMediaMediaItemUnsupportedReason = "explicitContentSettings"

	PlayMediaMediaItemUnsupportedReasonLoginRequired PlayMediaMediaItemUnsupportedReason = "loginRequired"

	PlayMediaMediaItemUnsupportedReasonRegionRestriction PlayMediaMediaItemUnsupportedReason = "regionRestriction"

	PlayMediaMediaItemUnsupportedReasonRestrictedContent PlayMediaMediaItemUnsupportedReason = "restrictedContent"

	PlayMediaMediaItemUnsupportedReasonSubscriptionRequired PlayMediaMediaItemUnsupportedReason = "subscriptionRequired"

	PlayMediaMediaItemUnsupportedReasonUnsupportedMediaType PlayMediaMediaItemUnsupportedReason = "unsupportedMediaType"
)

// Defines values for PlaybackQueueLocation.
const (
	PlaybackQueueLocationLater PlaybackQueueLocation = "later"

	PlaybackQueueLocationNext PlaybackQueueLocation = "next"

	PlaybackQueueLocationNow PlaybackQueueLocation = "now"

	PlaybackQueueLocationUnknown PlaybackQueueLocation = "unknown"
)

// Defines values for PlaybackRepeatMode.
const (
	PlaybackRepeatModeAll PlaybackRepeatMode = "all"

	PlaybackRepeatModeNone PlaybackRepeatMode = "none"

	PlaybackRepeatModeOne PlaybackRepeatMode = "one"

	PlaybackRepeatModeUnknown PlaybackRepeatMode = "unknown"
)

// Defines values for ProtocolExceptionReason.
const (
	ProtocolExceptionReasonBusy ProtocolExceptionReason = "busy"

	ProtocolExceptionReasonComplex ProtocolExceptionReason = "complex"

	ProtocolExceptionReasonDeprecated ProtocolExceptionReason = "deprecated"

	ProtocolExceptionReasonInternal ProtocolExceptionReason = "internal"

	ProtocolExceptionReasonInvalid ProtocolExceptionReason = "invalid"

	ProtocolExceptionReasonUnauthorized ProtocolExceptionReason = "unauthorized"

	ProtocolExceptionReasonUnexpected ProtocolExceptionReason = "unexpected"

	ProtocolExceptionReasonUnparseable ProtocolExceptionReason = "unparseable"

	ProtocolExceptionReasonUnsupported ProtocolExceptionReason = "unsupported"
)

// Defines values for QueueActivityReportEvent.
const (
	QueueActivityReportEventLocalCommandBookmark QueueActivityReportEvent = "local.command.bookmark"

	QueueActivityReportEventLocalCommandDislike QueueActivityReportEvent = "local.command.dislike"

	QueueActivityReportEventLocalCommandLike QueueActivityReportEvent = "local.command.like"

	QueueActivityReportEventLocalPlayingContinued QueueActivityReportEvent = "local.playing.continued"

	QueueActivityReportEventLocalPlayingElapsed QueueActivityReportEvent = "local.playing.elapsed"

	QueueActivityReportEventLocalPlayingFastForward QueueActivityReportEvent = "local.playing.fastForward"

	QueueActivityReportEventLocalPlayingFastRewind QueueActivityReportEvent = "local.playing.fastRewind"

	QueueActivityReportEventLocalPlayingPaused QueueActivityReportEvent = "local.playing.paused"

	QueueActivityReportEventLocalPlayingScrub QueueActivityReportEvent = "local.playing.scrub"

	QueueActivityReportEventLocalPlayingTransitionedNaturally QueueActivityReportEvent = "local.playing.transitioned.naturally"

	QueueActivityReportEventLocalPlayingTransitionedQueueReplaced QueueActivityReportEvent = "local.playing.transitioned.queue_replaced"

	QueueActivityReportEventLocalPlayingTransitionedSkipNext QueueActivityReportEvent = "local.playing.transitioned.skip_next"

	QueueActivityReportEventLocalPlayingTransitionedSkipPrevious QueueActivityReportEvent = "local.playing.transitioned.skip_previous"

	QueueActivityReportEventLocalStoppedNaturally QueueActivityReportEvent = "local.stopped.naturally"

	QueueActivityReportEventLocalStoppedSkipPastEnd QueueActivityReportEvent = "local.stopped.skip_past_end"
)

// Defines values for UpdateMediaAffinityIntentResponseCode.
const (
	UpdateMediaAffinityIntentResponseCodeFailure UpdateMediaAffinityIntentResponseCode = "failure"

	UpdateMediaAffinityIntentResponseCodeFailureRequiringAppLaunch UpdateMediaAffinityIntentResponseCode = "failureRequiringAppLaunch"

	UpdateMediaAffinityIntentResponseCodeInProgress UpdateMediaAffinityIntentResponseCode = "inProgress"

	UpdateMediaAffinityIntentResponseCodeSuccess UpdateMediaAffinityIntentResponseCode = "success"

	UpdateMediaAffinityIntentResponseCodeUnspecified UpdateMediaAffinityIntentResponseCode = "unspecified"
)

// Defines values for UpdateMediaAffinityMediaItemUnsupportedReason.
const (
	UpdateMediaAffinityMediaItemUnsupportedReasonExplicitContentSettings UpdateMediaAffinityMediaItemUnsupportedReason = "explicitContentSettings"

	UpdateMediaAffinityMediaItemUnsupportedReasonLoginRequired UpdateMediaAffinityMediaItemUnsupportedReason = "loginRequired"

	UpdateMediaAffinityMediaItemUnsupportedReasonSubscriptionRequired UpdateMediaAffinityMediaItemUnsupportedReason = "subscriptionRequired"

	UpdateMediaAffinityMediaItemUnsupportedReasonUnsupportedMediaType UpdateMediaAffinityMediaItemUnsupportedReason = "unsupportedMediaType"
)

// AddMediaIntent defines model for AddMediaIntent.
type AddMediaIntent struct {
	// Embedded struct due to allOf(#/components/schemas/Intent)
	Intent `yaml:",inline"`
}

// AddMediaIntentHandlingConfirmInvocationResponse defines model for AddMediaIntentHandlingConfirmInvocationResponse.
type AddMediaIntentHandlingConfirmInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// AddMediaIntentHandlingHandleInvocationResponse defines model for AddMediaIntentHandlingHandleInvocationResponse.
type AddMediaIntentHandlingHandleInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// AddMediaIntentHandlingInvocation defines model for AddMediaIntentHandlingInvocation.
type AddMediaIntentHandlingInvocation struct {
	// Embedded struct due to allOf(#/components/schemas/Invocation)
	Invocation `yaml:",inline"`
}

// AddMediaIntentHandlingInvocationResponse defines model for AddMediaIntentHandlingInvocationResponse.
type AddMediaIntentHandlingInvocationResponse interface{}

// AddMediaIntentHandlingResolveMediaDestinationInvocationResponse defines model for AddMediaIntentHandlingResolveMediaDestinationInvocationResponse.
type AddMediaIntentHandlingResolveMediaDestinationInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// AddMediaIntentHandlingResolveMediaItemsInvocationResponse defines model for AddMediaIntentHandlingResolveMediaItemsInvocationResponse.
type AddMediaIntentHandlingResolveMediaItemsInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// AddMediaIntentResponse defines model for AddMediaIntentResponse.
type AddMediaIntentResponse struct {
	// Embedded struct due to allOf(#/components/schemas/IntentResponse)
	IntentResponse `yaml:",inline"`
}

// AddMediaIntentResponseCode defines model for AddMediaIntentResponseCode.
type AddMediaIntentResponseCode string

// AddMediaMediaDestinationResolutionResult defines model for AddMediaMediaDestinationResolutionResult.
type AddMediaMediaDestinationResolutionResult struct {
	// Embedded struct due to allOf(#/components/schemas/IntentResolutionResult)
	IntentResolutionResult `yaml:",inline"`
}

// AddMediaMediaDestinationUnsupportedReason defines model for AddMediaMediaDestinationUnsupportedReason.
type AddMediaMediaDestinationUnsupportedReason string

// AddMediaMediaItemResolutionResult defines model for AddMediaMediaItemResolutionResult.
type AddMediaMediaItemResolutionResult struct {
	// Embedded struct due to allOf(#/components/schemas/IntentResolutionResult)
	IntentResolutionResult `yaml:",inline"`
}

// AddMediaMediaItemUnsupportedReason defines model for AddMediaMediaItemUnsupportedReason.
type AddMediaMediaItemUnsupportedReason string

// BooleanResolutionResult defines model for BooleanResolutionResult.
type BooleanResolutionResult struct {
	// Embedded struct due to allOf(#/components/schemas/IntentResolutionResult)
	IntentResolutionResult `yaml:",inline"`
}

// Constraints defines model for Constraints.
type Constraints struct {
	AllowExplicitContent         *bool `json:"allowExplicitContent,omitempty"`
	MaximumQueueSegmentItemCount *int  `json:"maximumQueueSegmentItemCount,omitempty"`
	UpdateUserTasteProfile       *bool `json:"updateUserTasteProfile,omitempty"`
}

// Content defines model for Content.
type Content struct {
	Attributes *ContentAttributes `json:"attributes,omitempty"`
	Control    *string            `json:"control,omitempty"`
	Identifier ContentIdentifier  `json:"identifier"`
	IsLive     *bool              `json:"isLive,omitempty"`
	PlayIndex  *int               `json:"playIndex,omitempty"`
	Url        *string            `json:"url,omitempty"`
}

// ContentAttributes defines model for ContentAttributes.
type ContentAttributes struct {
	AlbumName  *string `json:"albumName,omitempty"`
	ArtistName *string `json:"artistName,omitempty"`
	Artwork    *struct {
		Url *string `json:"url,omitempty"`
	} `json:"artwork,omitempty"`
	ComposerName     *string   `json:"composerName,omitempty"`
	DurationInMillis *int      `json:"durationInMillis,omitempty"`
	GenreNames       *[]string `json:"genreNames,omitempty"`
	Name             *string   `json:"name,omitempty"`
	TrackNumber      *int      `json:"trackNumber,omitempty"`
}

// ContentIdentifier defines model for ContentIdentifier.
type ContentIdentifier string

// DateComponents defines model for DateComponents.
type DateComponents interface{}

// DateComponentsRange defines model for DateComponentsRange.
type DateComponentsRange struct {
	EndDateComponents   *DateComponents `json:"endDateComponents,omitempty"`
	StartDateComponents *DateComponents `json:"startDateComponents,omitempty"`
}

// ExecutionMetrics defines model for ExecutionMetrics.
type ExecutionMetrics struct {
	Completed *time.Time `json:"completed,omitempty"`
	Duration  *float32   `json:"duration,omitempty"`
	Received  *time.Time `json:"received,omitempty"`
}

// ExplicitDateComponents defines model for ExplicitDateComponents.
type ExplicitDateComponents struct {
	CalendarIdentifier *string `json:"calendarIdentifier,omitempty"`
	Day                *int32  `json:"day,omitempty"`
	Era                *int32  `json:"era,omitempty"`
	Hour               *int32  `json:"hour,omitempty"`
	Minute             *int32  `json:"minute,omitempty"`
	Month              *int32  `json:"month,omitempty"`
	Nanosecond         *int32  `json:"nanosecond,omitempty"`
	Second             *int32  `json:"second,omitempty"`
	TimeZone           *string `json:"timeZone,omitempty"`
	Year               *int32  `json:"year,omitempty"`
}

// ExtensionConfig defines model for ExtensionConfig.
type ExtensionConfig struct {
	Hdr    *map[string]interface{} `json:"hdr,omitempty"`
	Intent struct {
		AddMedia *struct {
			// Embedded struct due to allOf(#/components/schemas/ExtensionEndpointConfig)
			ExtensionEndpointConfig `yaml:",inline"`
		} `json:"addMedia,omitempty"`
		Hdr       *map[string]interface{} `json:"hdr,omitempty"`
		PlayMedia struct {
			// Embedded struct due to allOf(#/components/schemas/ExtensionEndpointConfig)
			ExtensionEndpointConfig `yaml:",inline"`
		} `json:"playMedia"`
		UpdateMediaAffinity *struct {
			// Embedded struct due to allOf(#/components/schemas/ExtensionEndpointConfig)
			ExtensionEndpointConfig `yaml:",inline"`
		} `json:"updateMediaAffinity,omitempty"`
	} `json:"intent"`
	Media struct {
		Queues *struct {
			Hdr       *map[string]interface{} `json:"hdr,omitempty"`
			PlayMedia *struct {
				Hdr *map[string]interface{} `json:"hdr,omitempty"`
				Url *string                 `json:"url,omitempty"`
			} `json:"playMedia,omitempty"`
			UpdateActivity *struct {
				Hdr *map[string]interface{} `json:"hdr,omitempty"`
				Url *string                 `json:"url,omitempty"`
			} `json:"updateActivity,omitempty"`
		} `json:"queues,omitempty"`
	} `json:"media"`
	Url     *string `json:"url,omitempty"`
	Version string  `json:"version"`
}

// ExtensionConfigTag defines model for ExtensionConfigTag.
type ExtensionConfigTag string

// ExtensionEndpointConfig defines model for ExtensionEndpointConfig.
type ExtensionEndpointConfig struct {
	Hdr *map[string]interface{} `json:"hdr,omitempty"`
	Url *string                 `json:"url,omitempty"`
}

// Intent defines model for Intent.
type Intent struct {
	Class      string `json:"class"`
	Identifier string `json:"identifier"`
}

// IntentResolutionResult defines model for IntentResolutionResult.
type IntentResolutionResult struct {
	Class       string                  `json:"class"`
	NeedsValue  *map[string]interface{} `json:"needsValue,omitempty"`
	NotRequired *map[string]interface{} `json:"notRequired,omitempty"`
	Unsupported *map[string]interface{} `json:"unsupported,omitempty"`
}

// IntentResponse defines model for IntentResponse.
type IntentResponse struct {
	Class        string        `json:"class"`
	UserActivity *UserActivity `json:"userActivity"`
}

// Invocation defines model for Invocation.
type Invocation struct {
	Method  string                  `json:"method"`
	Params  *map[string]interface{} `json:"params"`
	Session *Session                `json:"session,omitempty"`
}

// InvocationResponse defines model for InvocationResponse.
type InvocationResponse struct {
	Debug   *ServiceDebugReference  `json:"debug,omitempty"`
	Method  string                  `json:"method"`
	Metrics *ExecutionMetrics       `json:"metrics,omitempty"`
	Result  *map[string]interface{} `json:"result"`
}

// MediaAffinityType defines model for MediaAffinityType.
type MediaAffinityType string

// MediaAffinityTypeResolutionResult defines model for MediaAffinityTypeResolutionResult.
type MediaAffinityTypeResolutionResult struct {
	// Embedded struct due to allOf(#/components/schemas/IntentResolutionResult)
	IntentResolutionResult `yaml:",inline"`
}

// MediaDestination defines model for MediaDestination.
type MediaDestination struct {
	MediaDestinationType MediaDestinationMediaDestinationType `json:"mediaDestinationType"`
}

// MediaDestinationMediaDestinationType defines model for MediaDestination.MediaDestinationType.
type MediaDestinationMediaDestinationType string

// MediaItem defines model for MediaItem.
type MediaItem struct {
	Artist     *string       `json:"artist,omitempty"`
	Identifier string        `json:"identifier"`
	Title      *string       `json:"title,omitempty"`
	Type       MediaItemType `json:"type"`
}

// MediaItemType defines model for MediaItemType.
type MediaItemType string

// MediaReference defines model for MediaReference.
type MediaReference string

// MediaSearch defines model for MediaSearch.
type MediaSearch struct {
	AlbumName       *string              `json:"albumName,omitempty"`
	ArtistName      *string              `json:"artistName,omitempty"`
	GenreNames      *[]string            `json:"genreNames,omitempty"`
	MediaIdentifier *string              `json:"mediaIdentifier,omitempty"`
	MediaName       *string              `json:"mediaName,omitempty"`
	MediaType       *MediaItemType       `json:"mediaType,omitempty"`
	MoodNames       *[]string            `json:"moodNames,omitempty"`
	Reference       *MediaReference      `json:"reference,omitempty"`
	ReleaseDate     *DateComponentsRange `json:"releaseDate,omitempty"`
	SortOrder       *MediaSortOrder      `json:"sortOrder,omitempty"`
}

// MediaSortOrder defines model for MediaSortOrder.
type MediaSortOrder string

// PlayMediaControl defines model for PlayMediaControl.
type PlayMediaControl struct {
	Activity *PlayMediaControlActivity   `json:"activity,omitempty"`
	Commands *PlayMediaControlCommandSet `json:"commands,omitempty"`
	Scheme   PlayMediaControlScheme      `json:"scheme"`
}

// PlayMediaControlActivity defines model for PlayMediaControlActivity.
type PlayMediaControlActivity struct {
	PlayElapsed         *int `json:"playElapsed,omitempty"`
	PlayElapsedInterval *int `json:"playElapsedInterval,omitempty"`
	PlayPaused          *int `json:"playPaused,omitempty"`
}

// PlayMediaControlCommandSet defines model for PlayMediaControlCommandSet.
type PlayMediaControlCommandSet struct {
	BookmarkTrack          *bool `json:"bookmarkTrack,omitempty"`
	DislikeTrack           *bool `json:"dislikeTrack,omitempty"`
	LikeTrack              *bool `json:"likeTrack,omitempty"`
	NextTrack              *bool `json:"nextTrack,omitempty"`
	PreferSkipBackward     *bool `json:"preferSkipBackward,omitempty"`
	PreferSkipForward      *bool `json:"preferSkipForward,omitempty"`
	PreviousTrack          *bool `json:"previousTrack,omitempty"`
	SeekToPlaybackPosition *bool `json:"seekToPlaybackPosition,omitempty"`
	SkipBackward           *bool `json:"skipBackward,omitempty"`
	SkipForward            *bool `json:"skipForward,omitempty"`
}

// PlayMediaControlScheme defines model for PlayMediaControlScheme.
type PlayMediaControlScheme string

// PlayMediaIntent defines model for PlayMediaIntent.
type PlayMediaIntent struct {
	// Embedded struct due to allOf(#/components/schemas/Intent)
	Intent `yaml:",inline"`
}

// PlayMediaIntentHandlingHandleInvocationResponse defines model for PlayMediaIntentHandlingHandleInvocationResponse.
type PlayMediaIntentHandlingHandleInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// PlayMediaIntentHandlingInvocation defines model for PlayMediaIntentHandlingInvocation.
type PlayMediaIntentHandlingInvocation struct {
	// Embedded struct due to allOf(#/components/schemas/Invocation)
	Invocation `yaml:",inline"`
}

// PlayMediaIntentHandlingInvocationResponse defines model for PlayMediaIntentHandlingInvocationResponse.
type PlayMediaIntentHandlingInvocationResponse interface{}

// PlayMediaIntentHandlingResolveMediaItemsInvocationResponse defines model for PlayMediaIntentHandlingResolveMediaItemsInvocationResponse.
type PlayMediaIntentHandlingResolveMediaItemsInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// PlayMediaIntentHandlingResolvePlayShuffledInvocationResponse defines model for PlayMediaIntentHandlingResolvePlayShuffledInvocationResponse.
type PlayMediaIntentHandlingResolvePlayShuffledInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// PlayMediaIntentHandlingResolvePlaybackQueueLocationInvocationResponse defines model for PlayMediaIntentHandlingResolvePlaybackQueueLocationInvocationResponse.
type PlayMediaIntentHandlingResolvePlaybackQueueLocationInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// PlayMediaIntentHandlingResolvePlaybackRepeatModeInvocationResponse defines model for PlayMediaIntentHandlingResolvePlaybackRepeatModeInvocationResponse.
type PlayMediaIntentHandlingResolvePlaybackRepeatModeInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// PlayMediaIntentHandlingResolveResumePlaybackInvocationResponse defines model for PlayMediaIntentHandlingResolveResumePlaybackInvocationResponse.
type PlayMediaIntentHandlingResolveResumePlaybackInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// PlayMediaIntentResponse defines model for PlayMediaIntentResponse.
type PlayMediaIntentResponse struct {
	// Embedded struct due to allOf(#/components/schemas/IntentResponse)
	IntentResponse `yaml:",inline"`
}

// PlayMediaIntentResponseCode defines model for PlayMediaIntentResponseCode.
type PlayMediaIntentResponseCode string

// PlayMediaMediaItemResolutionResult defines model for PlayMediaMediaItemResolutionResult.
type PlayMediaMediaItemResolutionResult struct {
	// Embedded struct due to allOf(#/components/schemas/IntentResolutionResult)
	IntentResolutionResult `yaml:",inline"`
}

// PlayMediaMediaItemUnsupportedReason defines model for PlayMediaMediaItemUnsupportedReason.
type PlayMediaMediaItemUnsupportedReason string

// PlayMediaRequest defines model for PlayMediaRequest.
type PlayMediaRequest struct {
	Constraints  Constraints   `json:"constraints"`
	UserActivity *UserActivity `json:"userActivity"`
	Version      string        `json:"version"`
}

// PlaybackQueueLocation defines model for PlaybackQueueLocation.
type PlaybackQueueLocation string

// PlaybackQueueLocationResolutionResult defines model for PlaybackQueueLocationResolutionResult.
type PlaybackQueueLocationResolutionResult struct {
	// Embedded struct due to allOf(#/components/schemas/IntentResolutionResult)
	IntentResolutionResult `yaml:",inline"`
}

// PlaybackRepeatMode defines model for PlaybackRepeatMode.
type PlaybackRepeatMode string

// PlaybackRepeatModeResolutionResult defines model for PlaybackRepeatModeResolutionResult.
type PlaybackRepeatModeResolutionResult struct {
	// Embedded struct due to allOf(#/components/schemas/IntentResolutionResult)
	IntentResolutionResult `yaml:",inline"`
}

// PlayerContext defines model for PlayerContext.
type PlayerContext struct {
	ActivityIdentifier *string            `json:"activityIdentifier,omitempty"`
	ContentIdentifier  *ContentIdentifier `json:"contentIdentifier,omitempty"`
	OffsetInMillis     *int64             `json:"offsetInMillis,omitempty"`
	PlaybackSpeed      *float64           `json:"playbackSpeed,omitempty"`
	QueueIdentifier    *QueueIdentifier   `json:"queueIdentifier,omitempty"`
}

// ProtocolException defines model for ProtocolException.
type ProtocolException struct {
	Code           *int64                  `json:"code,omitempty"`
	MethodIndex    *int                    `json:"methodIndex,omitempty"`
	MethodName     *string                 `json:"methodName,omitempty"`
	Reason         ProtocolExceptionReason `json:"reason"`
	RetryWithDelay *float32                `json:"retryWithDelay,omitempty"`
	Trace          *[]string               `json:"trace,omitempty"`
}

// ProtocolExceptionInvocationResponse defines model for ProtocolExceptionInvocationResponse.
type ProtocolExceptionInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// ProtocolExceptionReason defines model for ProtocolExceptionReason.
type ProtocolExceptionReason string

// Queue defines model for Queue.
type Queue struct {
	Content            []Content            `json:"content"`
	ContentItemsCount  *int                 `json:"contentItemsCount"`
	Controls           *QueueControlMapping `json:"controls,omitempty"`
	Identifier         QueueIdentifier      `json:"identifier"`
	InsertPointer      *QueueInsertPointer  `json:"insertPointer,omitempty"`
	NextContentUrl     *string              `json:"nextContentUrl"`
	PlayPointer        *QueuePlayPointer    `json:"playPointer"`
	PrerollSeconds     *float64             `json:"prerollSeconds,omitempty"`
	PreviousContentUrl *string              `json:"previousContentUrl"`
	SkipsRemaining     *int                 `json:"skipsRemaining"`
	Version            string               `json:"version"`
}

// QueueActivityReportEvent defines model for QueueActivityReportEvent.
type QueueActivityReportEvent string

// QueueControlMapping defines model for QueueControlMapping.
type QueueControlMapping struct {
	Default              PlayMediaControl            `json:"default"`
	AdditionalProperties map[string]PlayMediaControl `json:"-"`
}

// QueueIdentifier defines model for QueueIdentifier.
type QueueIdentifier string

// QueueInsertPointer defines model for QueueInsertPointer.
type QueueInsertPointer struct {
	AfterIdentifier *ContentIdentifier `json:"afterIdentifier,omitempty"`
	Replace         *bool              `json:"replace,omitempty"`
}

// QueuePlayPointer defines model for QueuePlayPointer.
type QueuePlayPointer struct {
	ContentIdentifier *ContentIdentifier `json:"contentIdentifier,omitempty"`
	OffsetInMillis    *int64             `json:"offsetInMillis,omitempty"`
}

// ServiceDebugReference defines model for ServiceDebugReference.
type ServiceDebugReference string

// Session defines model for Session.
type Session struct {
	Constraints   Constraints    `json:"constraints"`
	Deadline      time.Time      `json:"deadline"`
	Identifier    string         `json:"identifier"`
	PlayerContext *PlayerContext `json:"playerContext,omitempty"`
	Requested     time.Time      `json:"requested"`
	Version       string         `json:"version"`
}

// UpdateActivityRequest defines model for UpdateActivityRequest.
type UpdateActivityRequest struct {
	Constraints       *Constraints             `json:"constraints,omitempty"`
	NowPlaying        *PlayerContext           `json:"nowPlaying,omitempty"`
	PreviouslyPlaying *PlayerContext           `json:"previouslyPlaying,omitempty"`
	Report            QueueActivityReportEvent `json:"report"`
	Timestamp         time.Time                `json:"timestamp"`
	UserActivity      *UserActivity            `json:"userActivity"`
	Version           string                   `json:"version"`
}

// UpdateActivityResponse defines model for UpdateActivityResponse.
type UpdateActivityResponse struct {
	Queue        *Queue        `json:"queue,omitempty"`
	UserActivity *UserActivity `json:"userActivity"`
}

// UpdateMediaAffinityIntent defines model for UpdateMediaAffinityIntent.
type UpdateMediaAffinityIntent struct {
	// Embedded struct due to allOf(#/components/schemas/Intent)
	Intent `yaml:",inline"`
}

// UpdateMediaAffinityIntentHandlingHandleInvocationResponse defines model for UpdateMediaAffinityIntentHandlingHandleInvocationResponse.
type UpdateMediaAffinityIntentHandlingHandleInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// UpdateMediaAffinityIntentHandlingInvocation defines model for UpdateMediaAffinityIntentHandlingInvocation.
type UpdateMediaAffinityIntentHandlingInvocation struct {
	// Embedded struct due to allOf(#/components/schemas/Invocation)
	Invocation `yaml:",inline"`
}

// UpdateMediaAffinityIntentHandlingInvocationResponse defines model for UpdateMediaAffinityIntentHandlingInvocationResponse.
type UpdateMediaAffinityIntentHandlingInvocationResponse interface{}

// UpdateMediaAffinityIntentHandlingResolveAffinityTypeInvocationResponse defines model for UpdateMediaAffinityIntentHandlingResolveAffinityTypeInvocationResponse.
type UpdateMediaAffinityIntentHandlingResolveAffinityTypeInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// UpdateMediaAffinityIntentHandlingResolveMediaItemsInvocationResponse defines model for UpdateMediaAffinityIntentHandlingResolveMediaItemsInvocationResponse.
type UpdateMediaAffinityIntentHandlingResolveMediaItemsInvocationResponse struct {
	// Embedded struct due to allOf(#/components/schemas/InvocationResponse)
	InvocationResponse `yaml:",inline"`
}

// UpdateMediaAffinityIntentResponse defines model for UpdateMediaAffinityIntentResponse.
type UpdateMediaAffinityIntentResponse struct {
	// Embedded struct due to allOf(#/components/schemas/IntentResponse)
	IntentResponse `yaml:",inline"`
}

// UpdateMediaAffinityIntentResponseCode defines model for UpdateMediaAffinityIntentResponseCode.
type UpdateMediaAffinityIntentResponseCode string

// UpdateMediaAffinityMediaItemResolutionResult defines model for UpdateMediaAffinityMediaItemResolutionResult.
type UpdateMediaAffinityMediaItemResolutionResult struct {
	// Embedded struct due to allOf(#/components/schemas/IntentResolutionResult)
	IntentResolutionResult `yaml:",inline"`
}

// UpdateMediaAffinityMediaItemUnsupportedReason defines model for UpdateMediaAffinityMediaItemUnsupportedReason.
type UpdateMediaAffinityMediaItemUnsupportedReason string

// UserActivity defines model for UserActivity.
type UserActivity struct {
	ActivityType         string                  `json:"activityType"`
	PersistentIdentifier *string                 `json:"persistentIdentifier,omitempty"`
	Title                *string                 `json:"title,omitempty"`
	UserInfo             *map[string]interface{} `json:"userInfo,omitempty"`
	Version              string                  `json:"version"`
}

// ExtensionConfigurationParams defines parameters for ExtensionConfiguration.
type ExtensionConfigurationParams struct {
	XApplecloudextensionSessionId  string              `json:"x-applecloudextension-session-id"`
	XApplecloudextensionRetryCount *int                `json:"x-applecloudextension-retry-count,omitempty"`
	RequestTimeout                 int                 `json:"Request-Timeout"`
	UserAgent                      string              `json:"User-Agent"`
	AcceptLanguage                 string              `json:"Accept-Language"`
	IfNoneMatch                    *ExtensionConfigTag `json:"If-None-Match,omitempty"`
	CacheControl                   string              `json:"Cache-Control"`
}

// AddMediaIntentHandlingJSONBody defines parameters for AddMediaIntentHandling.
type AddMediaIntentHandlingJSONBody []AddMediaIntentHandlingInvocation

// AddMediaIntentHandlingParams defines parameters for AddMediaIntentHandling.
type AddMediaIntentHandlingParams struct {
	XApplecloudextensionSessionId  string `json:"x-applecloudextension-session-id"`
	XApplecloudextensionRetryCount *int   `json:"x-applecloudextension-retry-count,omitempty"`
	RequestTimeout                 int    `json:"Request-Timeout"`
	UserAgent                      string `json:"User-Agent"`
	AcceptLanguage                 string `json:"Accept-Language"`
}

// PlayMediaIntentHandlingJSONBody defines parameters for PlayMediaIntentHandling.
type PlayMediaIntentHandlingJSONBody []PlayMediaIntentHandlingInvocation

// PlayMediaIntentHandlingParams defines parameters for PlayMediaIntentHandling.
type PlayMediaIntentHandlingParams struct {
	XApplecloudextensionSessionId  string `json:"x-applecloudextension-session-id"`
	XApplecloudextensionRetryCount *int   `json:"x-applecloudextension-retry-count,omitempty"`
	RequestTimeout                 int    `json:"Request-Timeout"`
	UserAgent                      string `json:"User-Agent"`
	AcceptLanguage                 string `json:"Accept-Language"`
}

// UpdateMediaAffinityIntentHandlingJSONBody defines parameters for UpdateMediaAffinityIntentHandling.
type UpdateMediaAffinityIntentHandlingJSONBody []UpdateMediaAffinityIntentHandlingInvocation

// UpdateMediaAffinityIntentHandlingParams defines parameters for UpdateMediaAffinityIntentHandling.
type UpdateMediaAffinityIntentHandlingParams struct {
	XApplecloudextensionSessionId  string `json:"x-applecloudextension-session-id"`
	XApplecloudextensionRetryCount *int   `json:"x-applecloudextension-retry-count,omitempty"`
	RequestTimeout                 int    `json:"Request-Timeout"`
	UserAgent                      string `json:"User-Agent"`
	AcceptLanguage                 string `json:"Accept-Language"`
}

// PlayMediaOnQueueJSONBody defines parameters for PlayMediaOnQueue.
type PlayMediaOnQueueJSONBody PlayMediaRequest

// PlayMediaOnQueueParams defines parameters for PlayMediaOnQueue.
type PlayMediaOnQueueParams struct {
	XApplecloudextensionSessionId  string `json:"x-applecloudextension-session-id"`
	XApplecloudextensionRetryCount *int   `json:"x-applecloudextension-retry-count,omitempty"`
	UserAgent                      string `json:"User-Agent"`
	AcceptLanguage                 string `json:"Accept-Language"`
}

// UpdateActivityOnQueueJSONBody defines parameters for UpdateActivityOnQueue.
type UpdateActivityOnQueueJSONBody UpdateActivityRequest

// UpdateActivityOnQueueParams defines parameters for UpdateActivityOnQueue.
type UpdateActivityOnQueueParams struct {
	XApplecloudextensionSessionId  string `json:"x-applecloudextension-session-id"`
	XApplecloudextensionRetryCount *int   `json:"x-applecloudextension-retry-count,omitempty"`
	UserAgent                      string `json:"User-Agent"`
	AcceptLanguage                 string `json:"Accept-Language"`
}

// AddMediaIntentHandlingJSONRequestBody defines body for AddMediaIntentHandling for application/json ContentType.
type AddMediaIntentHandlingJSONRequestBody AddMediaIntentHandlingJSONBody

// PlayMediaIntentHandlingJSONRequestBody defines body for PlayMediaIntentHandling for application/json ContentType.
type PlayMediaIntentHandlingJSONRequestBody PlayMediaIntentHandlingJSONBody

// UpdateMediaAffinityIntentHandlingJSONRequestBody defines body for UpdateMediaAffinityIntentHandling for application/json ContentType.
type UpdateMediaAffinityIntentHandlingJSONRequestBody UpdateMediaAffinityIntentHandlingJSONBody

// PlayMediaOnQueueJSONRequestBody defines body for PlayMediaOnQueue for application/json ContentType.
type PlayMediaOnQueueJSONRequestBody PlayMediaOnQueueJSONBody

// UpdateActivityOnQueueJSONRequestBody defines body for UpdateActivityOnQueue for application/json ContentType.
type UpdateActivityOnQueueJSONRequestBody UpdateActivityOnQueueJSONBody

// Getter for additional properties for QueueControlMapping. Returns the specified
// element and whether it was found
func (a QueueControlMapping) Get(fieldName string) (value PlayMediaControl, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for QueueControlMapping
func (a *QueueControlMapping) Set(fieldName string, value PlayMediaControl) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]PlayMediaControl)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for QueueControlMapping to handle AdditionalProperties
func (a *QueueControlMapping) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["default"]; found {
		err = json.Unmarshal(raw, &a.Default)
		if err != nil {
			return fmt.Errorf("error reading 'default': %w", err)
		}
		delete(object, "default")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]PlayMediaControl)
		for fieldName, fieldBuf := range object {
			var fieldVal PlayMediaControl
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for QueueControlMapping to handle AdditionalProperties
func (a QueueControlMapping) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["default"], err = json.Marshal(a.Default)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'default': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ExtensionConfiguration request
	ExtensionConfiguration(ctx context.Context, params *ExtensionConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMediaIntentHandling request with any body
	AddMediaIntentHandlingWithBody(ctx context.Context, params *AddMediaIntentHandlingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddMediaIntentHandling(ctx context.Context, params *AddMediaIntentHandlingParams, body AddMediaIntentHandlingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlayMediaIntentHandling request with any body
	PlayMediaIntentHandlingWithBody(ctx context.Context, params *PlayMediaIntentHandlingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PlayMediaIntentHandling(ctx context.Context, params *PlayMediaIntentHandlingParams, body PlayMediaIntentHandlingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMediaAffinityIntentHandling request with any body
	UpdateMediaAffinityIntentHandlingWithBody(ctx context.Context, params *UpdateMediaAffinityIntentHandlingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMediaAffinityIntentHandling(ctx context.Context, params *UpdateMediaAffinityIntentHandlingParams, body UpdateMediaAffinityIntentHandlingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlayMediaOnQueue request with any body
	PlayMediaOnQueueWithBody(ctx context.Context, params *PlayMediaOnQueueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PlayMediaOnQueue(ctx context.Context, params *PlayMediaOnQueueParams, body PlayMediaOnQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateActivityOnQueue request with any body
	UpdateActivityOnQueueWithBody(ctx context.Context, params *UpdateActivityOnQueueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateActivityOnQueue(ctx context.Context, params *UpdateActivityOnQueueParams, body UpdateActivityOnQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ExtensionConfiguration(ctx context.Context, params *ExtensionConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExtensionConfigurationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMediaIntentHandlingWithBody(ctx context.Context, params *AddMediaIntentHandlingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMediaIntentHandlingRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMediaIntentHandling(ctx context.Context, params *AddMediaIntentHandlingParams, body AddMediaIntentHandlingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMediaIntentHandlingRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlayMediaIntentHandlingWithBody(ctx context.Context, params *PlayMediaIntentHandlingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlayMediaIntentHandlingRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlayMediaIntentHandling(ctx context.Context, params *PlayMediaIntentHandlingParams, body PlayMediaIntentHandlingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlayMediaIntentHandlingRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMediaAffinityIntentHandlingWithBody(ctx context.Context, params *UpdateMediaAffinityIntentHandlingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMediaAffinityIntentHandlingRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMediaAffinityIntentHandling(ctx context.Context, params *UpdateMediaAffinityIntentHandlingParams, body UpdateMediaAffinityIntentHandlingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMediaAffinityIntentHandlingRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlayMediaOnQueueWithBody(ctx context.Context, params *PlayMediaOnQueueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlayMediaOnQueueRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlayMediaOnQueue(ctx context.Context, params *PlayMediaOnQueueParams, body PlayMediaOnQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlayMediaOnQueueRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateActivityOnQueueWithBody(ctx context.Context, params *UpdateActivityOnQueueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateActivityOnQueueRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateActivityOnQueue(ctx context.Context, params *UpdateActivityOnQueueParams, body UpdateActivityOnQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateActivityOnQueueRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewExtensionConfigurationRequest generates requests for ExtensionConfiguration
func NewExtensionConfigurationRequest(server string, params *ExtensionConfigurationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-applecloudextension-session-id", runtime.ParamLocationHeader, params.XApplecloudextensionSessionId)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-applecloudextension-session-id", headerParam0)

	if params.XApplecloudextensionRetryCount != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-applecloudextension-retry-count", runtime.ParamLocationHeader, *params.XApplecloudextensionRetryCount)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-applecloudextension-retry-count", headerParam1)
	}

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Request-Timeout", runtime.ParamLocationHeader, params.RequestTimeout)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Request-Timeout", headerParam2)

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, params.UserAgent)
	if err != nil {
		return nil, err
	}

	req.Header.Set("User-Agent", headerParam3)

	var headerParam4 string

	headerParam4, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, params.AcceptLanguage)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Accept-Language", headerParam4)

	if params.IfNoneMatch != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam5)
	}

	var headerParam6 string

	headerParam6, err = runtime.StyleParamWithLocation("simple", false, "Cache-Control", runtime.ParamLocationHeader, params.CacheControl)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Cache-Control", headerParam6)

	return req, nil
}

// NewAddMediaIntentHandlingRequest calls the generic AddMediaIntentHandling builder with application/json body
func NewAddMediaIntentHandlingRequest(server string, params *AddMediaIntentHandlingParams, body AddMediaIntentHandlingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddMediaIntentHandlingRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddMediaIntentHandlingRequestWithBody generates requests for AddMediaIntentHandling with any type of body
func NewAddMediaIntentHandlingRequestWithBody(server string, params *AddMediaIntentHandlingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/intent/addMedia")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-applecloudextension-session-id", runtime.ParamLocationHeader, params.XApplecloudextensionSessionId)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-applecloudextension-session-id", headerParam0)

	if params.XApplecloudextensionRetryCount != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-applecloudextension-retry-count", runtime.ParamLocationHeader, *params.XApplecloudextensionRetryCount)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-applecloudextension-retry-count", headerParam1)
	}

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Request-Timeout", runtime.ParamLocationHeader, params.RequestTimeout)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Request-Timeout", headerParam2)

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, params.UserAgent)
	if err != nil {
		return nil, err
	}

	req.Header.Set("User-Agent", headerParam3)

	var headerParam4 string

	headerParam4, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, params.AcceptLanguage)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Accept-Language", headerParam4)

	return req, nil
}

// NewPlayMediaIntentHandlingRequest calls the generic PlayMediaIntentHandling builder with application/json body
func NewPlayMediaIntentHandlingRequest(server string, params *PlayMediaIntentHandlingParams, body PlayMediaIntentHandlingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPlayMediaIntentHandlingRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPlayMediaIntentHandlingRequestWithBody generates requests for PlayMediaIntentHandling with any type of body
func NewPlayMediaIntentHandlingRequestWithBody(server string, params *PlayMediaIntentHandlingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/intent/playMedia")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-applecloudextension-session-id", runtime.ParamLocationHeader, params.XApplecloudextensionSessionId)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-applecloudextension-session-id", headerParam0)

	if params.XApplecloudextensionRetryCount != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-applecloudextension-retry-count", runtime.ParamLocationHeader, *params.XApplecloudextensionRetryCount)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-applecloudextension-retry-count", headerParam1)
	}

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Request-Timeout", runtime.ParamLocationHeader, params.RequestTimeout)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Request-Timeout", headerParam2)

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, params.UserAgent)
	if err != nil {
		return nil, err
	}

	req.Header.Set("User-Agent", headerParam3)

	var headerParam4 string

	headerParam4, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, params.AcceptLanguage)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Accept-Language", headerParam4)

	return req, nil
}

// NewUpdateMediaAffinityIntentHandlingRequest calls the generic UpdateMediaAffinityIntentHandling builder with application/json body
func NewUpdateMediaAffinityIntentHandlingRequest(server string, params *UpdateMediaAffinityIntentHandlingParams, body UpdateMediaAffinityIntentHandlingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMediaAffinityIntentHandlingRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateMediaAffinityIntentHandlingRequestWithBody generates requests for UpdateMediaAffinityIntentHandling with any type of body
func NewUpdateMediaAffinityIntentHandlingRequestWithBody(server string, params *UpdateMediaAffinityIntentHandlingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/intent/updateMediaAffinity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-applecloudextension-session-id", runtime.ParamLocationHeader, params.XApplecloudextensionSessionId)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-applecloudextension-session-id", headerParam0)

	if params.XApplecloudextensionRetryCount != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-applecloudextension-retry-count", runtime.ParamLocationHeader, *params.XApplecloudextensionRetryCount)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-applecloudextension-retry-count", headerParam1)
	}

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Request-Timeout", runtime.ParamLocationHeader, params.RequestTimeout)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Request-Timeout", headerParam2)

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, params.UserAgent)
	if err != nil {
		return nil, err
	}

	req.Header.Set("User-Agent", headerParam3)

	var headerParam4 string

	headerParam4, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, params.AcceptLanguage)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Accept-Language", headerParam4)

	return req, nil
}

// NewPlayMediaOnQueueRequest calls the generic PlayMediaOnQueue builder with application/json body
func NewPlayMediaOnQueueRequest(server string, params *PlayMediaOnQueueParams, body PlayMediaOnQueueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPlayMediaOnQueueRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPlayMediaOnQueueRequestWithBody generates requests for PlayMediaOnQueue with any type of body
func NewPlayMediaOnQueueRequestWithBody(server string, params *PlayMediaOnQueueParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queues/playMedia")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-applecloudextension-session-id", runtime.ParamLocationHeader, params.XApplecloudextensionSessionId)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-applecloudextension-session-id", headerParam0)

	if params.XApplecloudextensionRetryCount != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-applecloudextension-retry-count", runtime.ParamLocationHeader, *params.XApplecloudextensionRetryCount)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-applecloudextension-retry-count", headerParam1)
	}

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, params.UserAgent)
	if err != nil {
		return nil, err
	}

	req.Header.Set("User-Agent", headerParam2)

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, params.AcceptLanguage)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Accept-Language", headerParam3)

	return req, nil
}

// NewUpdateActivityOnQueueRequest calls the generic UpdateActivityOnQueue builder with application/json body
func NewUpdateActivityOnQueueRequest(server string, params *UpdateActivityOnQueueParams, body UpdateActivityOnQueueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateActivityOnQueueRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateActivityOnQueueRequestWithBody generates requests for UpdateActivityOnQueue with any type of body
func NewUpdateActivityOnQueueRequestWithBody(server string, params *UpdateActivityOnQueueParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queues/updateActivity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-applecloudextension-session-id", runtime.ParamLocationHeader, params.XApplecloudextensionSessionId)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-applecloudextension-session-id", headerParam0)

	if params.XApplecloudextensionRetryCount != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-applecloudextension-retry-count", runtime.ParamLocationHeader, *params.XApplecloudextensionRetryCount)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-applecloudextension-retry-count", headerParam1)
	}

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, params.UserAgent)
	if err != nil {
		return nil, err
	}

	req.Header.Set("User-Agent", headerParam2)

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, params.AcceptLanguage)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Accept-Language", headerParam3)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ExtensionConfiguration request
	ExtensionConfigurationWithResponse(ctx context.Context, params *ExtensionConfigurationParams, reqEditors ...RequestEditorFn) (*ExtensionConfigurationResponse, error)

	// AddMediaIntentHandling request with any body
	AddMediaIntentHandlingWithBodyWithResponse(ctx context.Context, params *AddMediaIntentHandlingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMediaIntentHandlingResponse, error)

	AddMediaIntentHandlingWithResponse(ctx context.Context, params *AddMediaIntentHandlingParams, body AddMediaIntentHandlingJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMediaIntentHandlingResponse, error)

	// PlayMediaIntentHandling request with any body
	PlayMediaIntentHandlingWithBodyWithResponse(ctx context.Context, params *PlayMediaIntentHandlingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlayMediaIntentHandlingResponse, error)

	PlayMediaIntentHandlingWithResponse(ctx context.Context, params *PlayMediaIntentHandlingParams, body PlayMediaIntentHandlingJSONRequestBody, reqEditors ...RequestEditorFn) (*PlayMediaIntentHandlingResponse, error)

	// UpdateMediaAffinityIntentHandling request with any body
	UpdateMediaAffinityIntentHandlingWithBodyWithResponse(ctx context.Context, params *UpdateMediaAffinityIntentHandlingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMediaAffinityIntentHandlingResponse, error)

	UpdateMediaAffinityIntentHandlingWithResponse(ctx context.Context, params *UpdateMediaAffinityIntentHandlingParams, body UpdateMediaAffinityIntentHandlingJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMediaAffinityIntentHandlingResponse, error)

	// PlayMediaOnQueue request with any body
	PlayMediaOnQueueWithBodyWithResponse(ctx context.Context, params *PlayMediaOnQueueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlayMediaOnQueueResponse, error)

	PlayMediaOnQueueWithResponse(ctx context.Context, params *PlayMediaOnQueueParams, body PlayMediaOnQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*PlayMediaOnQueueResponse, error)

	// UpdateActivityOnQueue request with any body
	UpdateActivityOnQueueWithBodyWithResponse(ctx context.Context, params *UpdateActivityOnQueueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateActivityOnQueueResponse, error)

	UpdateActivityOnQueueWithResponse(ctx context.Context, params *UpdateActivityOnQueueParams, body UpdateActivityOnQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateActivityOnQueueResponse, error)
}

type ExtensionConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExtensionConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExtensionConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMediaIntentHandlingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AddMediaIntentHandlingInvocationResponse
}

// Status returns HTTPResponse.Status
func (r AddMediaIntentHandlingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMediaIntentHandlingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlayMediaIntentHandlingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PlayMediaIntentHandlingInvocationResponse
}

// Status returns HTTPResponse.Status
func (r PlayMediaIntentHandlingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlayMediaIntentHandlingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMediaAffinityIntentHandlingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UpdateMediaAffinityIntentHandlingInvocationResponse
}

// Status returns HTTPResponse.Status
func (r UpdateMediaAffinityIntentHandlingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMediaAffinityIntentHandlingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlayMediaOnQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Queue
}

// Status returns HTTPResponse.Status
func (r PlayMediaOnQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlayMediaOnQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateActivityOnQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateActivityResponse
}

// Status returns HTTPResponse.Status
func (r UpdateActivityOnQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateActivityOnQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ExtensionConfigurationWithResponse request returning *ExtensionConfigurationResponse
func (c *ClientWithResponses) ExtensionConfigurationWithResponse(ctx context.Context, params *ExtensionConfigurationParams, reqEditors ...RequestEditorFn) (*ExtensionConfigurationResponse, error) {
	rsp, err := c.ExtensionConfiguration(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExtensionConfigurationResponse(rsp)
}

// AddMediaIntentHandlingWithBodyWithResponse request with arbitrary body returning *AddMediaIntentHandlingResponse
func (c *ClientWithResponses) AddMediaIntentHandlingWithBodyWithResponse(ctx context.Context, params *AddMediaIntentHandlingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMediaIntentHandlingResponse, error) {
	rsp, err := c.AddMediaIntentHandlingWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMediaIntentHandlingResponse(rsp)
}

func (c *ClientWithResponses) AddMediaIntentHandlingWithResponse(ctx context.Context, params *AddMediaIntentHandlingParams, body AddMediaIntentHandlingJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMediaIntentHandlingResponse, error) {
	rsp, err := c.AddMediaIntentHandling(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMediaIntentHandlingResponse(rsp)
}

// PlayMediaIntentHandlingWithBodyWithResponse request with arbitrary body returning *PlayMediaIntentHandlingResponse
func (c *ClientWithResponses) PlayMediaIntentHandlingWithBodyWithResponse(ctx context.Context, params *PlayMediaIntentHandlingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlayMediaIntentHandlingResponse, error) {
	rsp, err := c.PlayMediaIntentHandlingWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlayMediaIntentHandlingResponse(rsp)
}

func (c *ClientWithResponses) PlayMediaIntentHandlingWithResponse(ctx context.Context, params *PlayMediaIntentHandlingParams, body PlayMediaIntentHandlingJSONRequestBody, reqEditors ...RequestEditorFn) (*PlayMediaIntentHandlingResponse, error) {
	rsp, err := c.PlayMediaIntentHandling(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlayMediaIntentHandlingResponse(rsp)
}

// UpdateMediaAffinityIntentHandlingWithBodyWithResponse request with arbitrary body returning *UpdateMediaAffinityIntentHandlingResponse
func (c *ClientWithResponses) UpdateMediaAffinityIntentHandlingWithBodyWithResponse(ctx context.Context, params *UpdateMediaAffinityIntentHandlingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMediaAffinityIntentHandlingResponse, error) {
	rsp, err := c.UpdateMediaAffinityIntentHandlingWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMediaAffinityIntentHandlingResponse(rsp)
}

func (c *ClientWithResponses) UpdateMediaAffinityIntentHandlingWithResponse(ctx context.Context, params *UpdateMediaAffinityIntentHandlingParams, body UpdateMediaAffinityIntentHandlingJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMediaAffinityIntentHandlingResponse, error) {
	rsp, err := c.UpdateMediaAffinityIntentHandling(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMediaAffinityIntentHandlingResponse(rsp)
}

// PlayMediaOnQueueWithBodyWithResponse request with arbitrary body returning *PlayMediaOnQueueResponse
func (c *ClientWithResponses) PlayMediaOnQueueWithBodyWithResponse(ctx context.Context, params *PlayMediaOnQueueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlayMediaOnQueueResponse, error) {
	rsp, err := c.PlayMediaOnQueueWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlayMediaOnQueueResponse(rsp)
}

func (c *ClientWithResponses) PlayMediaOnQueueWithResponse(ctx context.Context, params *PlayMediaOnQueueParams, body PlayMediaOnQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*PlayMediaOnQueueResponse, error) {
	rsp, err := c.PlayMediaOnQueue(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlayMediaOnQueueResponse(rsp)
}

// UpdateActivityOnQueueWithBodyWithResponse request with arbitrary body returning *UpdateActivityOnQueueResponse
func (c *ClientWithResponses) UpdateActivityOnQueueWithBodyWithResponse(ctx context.Context, params *UpdateActivityOnQueueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateActivityOnQueueResponse, error) {
	rsp, err := c.UpdateActivityOnQueueWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateActivityOnQueueResponse(rsp)
}

func (c *ClientWithResponses) UpdateActivityOnQueueWithResponse(ctx context.Context, params *UpdateActivityOnQueueParams, body UpdateActivityOnQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateActivityOnQueueResponse, error) {
	rsp, err := c.UpdateActivityOnQueue(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateActivityOnQueueResponse(rsp)
}

// ParseExtensionConfigurationResponse parses an HTTP response from a ExtensionConfigurationWithResponse call
func ParseExtensionConfigurationResponse(rsp *http.Response) (*ExtensionConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExtensionConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddMediaIntentHandlingResponse parses an HTTP response from a AddMediaIntentHandlingWithResponse call
func ParseAddMediaIntentHandlingResponse(rsp *http.Response) (*AddMediaIntentHandlingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMediaIntentHandlingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AddMediaIntentHandlingInvocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePlayMediaIntentHandlingResponse parses an HTTP response from a PlayMediaIntentHandlingWithResponse call
func ParsePlayMediaIntentHandlingResponse(rsp *http.Response) (*PlayMediaIntentHandlingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlayMediaIntentHandlingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PlayMediaIntentHandlingInvocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateMediaAffinityIntentHandlingResponse parses an HTTP response from a UpdateMediaAffinityIntentHandlingWithResponse call
func ParseUpdateMediaAffinityIntentHandlingResponse(rsp *http.Response) (*UpdateMediaAffinityIntentHandlingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMediaAffinityIntentHandlingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UpdateMediaAffinityIntentHandlingInvocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePlayMediaOnQueueResponse parses an HTTP response from a PlayMediaOnQueueWithResponse call
func ParsePlayMediaOnQueueResponse(rsp *http.Response) (*PlayMediaOnQueueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlayMediaOnQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Queue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateActivityOnQueueResponse parses an HTTP response from a UpdateActivityOnQueueWithResponse call
func ParseUpdateActivityOnQueueResponse(rsp *http.Response) (*UpdateActivityOnQueueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateActivityOnQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateActivityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Configuration Resource
	// (GET /configuration)
	ExtensionConfiguration(ctx echo.Context, params ExtensionConfigurationParams) error
	// addMedia
	// (POST /intent/addMedia)
	AddMediaIntentHandling(ctx echo.Context, params AddMediaIntentHandlingParams) error
	// playMedia
	// (POST /intent/playMedia)
	PlayMediaIntentHandling(ctx echo.Context, params PlayMediaIntentHandlingParams) error
	// updateMediaAffinity
	// (POST /intent/updateMediaAffinity)
	UpdateMediaAffinityIntentHandling(ctx echo.Context, params UpdateMediaAffinityIntentHandlingParams) error
	// playMedia
	// (POST /queues/playMedia)
	PlayMediaOnQueue(ctx echo.Context, params PlayMediaOnQueueParams) error
	// updateActivity
	// (POST /queues/updateActivity)
	UpdateActivityOnQueue(ctx echo.Context, params UpdateActivityOnQueueParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ExtensionConfiguration converts echo context to params.
func (w *ServerInterfaceWrapper) ExtensionConfiguration(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ExtensionConfigurationParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-applecloudextension-session-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-applecloudextension-session-id")]; found {
		var XApplecloudextensionSessionId string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-applecloudextension-session-id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-applecloudextension-session-id", runtime.ParamLocationHeader, valueList[0], &XApplecloudextensionSessionId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-applecloudextension-session-id: %s", err))
		}

		params.XApplecloudextensionSessionId = XApplecloudextensionSessionId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-applecloudextension-session-id is required, but not found"))
	}
	// ------------- Optional header parameter "x-applecloudextension-retry-count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-applecloudextension-retry-count")]; found {
		var XApplecloudextensionRetryCount int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-applecloudextension-retry-count, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-applecloudextension-retry-count", runtime.ParamLocationHeader, valueList[0], &XApplecloudextensionRetryCount)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-applecloudextension-retry-count: %s", err))
		}

		params.XApplecloudextensionRetryCount = &XApplecloudextensionRetryCount
	}
	// ------------- Required header parameter "Request-Timeout" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Timeout")]; found {
		var RequestTimeout int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Request-Timeout, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Request-Timeout", runtime.ParamLocationHeader, valueList[0], &RequestTimeout)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Request-Timeout: %s", err))
		}

		params.RequestTimeout = RequestTimeout
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Request-Timeout is required, but not found"))
	}
	// ------------- Required header parameter "User-Agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("User-Agent")]; found {
		var UserAgent string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for User-Agent, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, valueList[0], &UserAgent)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter User-Agent: %s", err))
		}

		params.UserAgent = UserAgent
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter User-Agent is required, but not found"))
	}
	// ------------- Required header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = AcceptLanguage
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Accept-Language is required, but not found"))
	}
	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch ExtensionConfigTag
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-None-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err))
		}

		params.IfNoneMatch = &IfNoneMatch
	}
	// ------------- Required header parameter "Cache-Control" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Cache-Control")]; found {
		var CacheControl string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Cache-Control, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Cache-Control", runtime.ParamLocationHeader, valueList[0], &CacheControl)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Cache-Control: %s", err))
		}

		params.CacheControl = CacheControl
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Cache-Control is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExtensionConfiguration(ctx, params)
	return err
}

// AddMediaIntentHandling converts echo context to params.
func (w *ServerInterfaceWrapper) AddMediaIntentHandling(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AddMediaIntentHandlingParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-applecloudextension-session-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-applecloudextension-session-id")]; found {
		var XApplecloudextensionSessionId string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-applecloudextension-session-id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-applecloudextension-session-id", runtime.ParamLocationHeader, valueList[0], &XApplecloudextensionSessionId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-applecloudextension-session-id: %s", err))
		}

		params.XApplecloudextensionSessionId = XApplecloudextensionSessionId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-applecloudextension-session-id is required, but not found"))
	}
	// ------------- Optional header parameter "x-applecloudextension-retry-count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-applecloudextension-retry-count")]; found {
		var XApplecloudextensionRetryCount int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-applecloudextension-retry-count, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-applecloudextension-retry-count", runtime.ParamLocationHeader, valueList[0], &XApplecloudextensionRetryCount)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-applecloudextension-retry-count: %s", err))
		}

		params.XApplecloudextensionRetryCount = &XApplecloudextensionRetryCount
	}
	// ------------- Required header parameter "Request-Timeout" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Timeout")]; found {
		var RequestTimeout int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Request-Timeout, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Request-Timeout", runtime.ParamLocationHeader, valueList[0], &RequestTimeout)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Request-Timeout: %s", err))
		}

		params.RequestTimeout = RequestTimeout
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Request-Timeout is required, but not found"))
	}
	// ------------- Required header parameter "User-Agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("User-Agent")]; found {
		var UserAgent string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for User-Agent, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, valueList[0], &UserAgent)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter User-Agent: %s", err))
		}

		params.UserAgent = UserAgent
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter User-Agent is required, but not found"))
	}
	// ------------- Required header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = AcceptLanguage
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Accept-Language is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddMediaIntentHandling(ctx, params)
	return err
}

// PlayMediaIntentHandling converts echo context to params.
func (w *ServerInterfaceWrapper) PlayMediaIntentHandling(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PlayMediaIntentHandlingParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-applecloudextension-session-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-applecloudextension-session-id")]; found {
		var XApplecloudextensionSessionId string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-applecloudextension-session-id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-applecloudextension-session-id", runtime.ParamLocationHeader, valueList[0], &XApplecloudextensionSessionId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-applecloudextension-session-id: %s", err))
		}

		params.XApplecloudextensionSessionId = XApplecloudextensionSessionId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-applecloudextension-session-id is required, but not found"))
	}
	// ------------- Optional header parameter "x-applecloudextension-retry-count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-applecloudextension-retry-count")]; found {
		var XApplecloudextensionRetryCount int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-applecloudextension-retry-count, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-applecloudextension-retry-count", runtime.ParamLocationHeader, valueList[0], &XApplecloudextensionRetryCount)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-applecloudextension-retry-count: %s", err))
		}

		params.XApplecloudextensionRetryCount = &XApplecloudextensionRetryCount
	}
	// ------------- Required header parameter "Request-Timeout" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Timeout")]; found {
		var RequestTimeout int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Request-Timeout, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Request-Timeout", runtime.ParamLocationHeader, valueList[0], &RequestTimeout)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Request-Timeout: %s", err))
		}

		params.RequestTimeout = RequestTimeout
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Request-Timeout is required, but not found"))
	}
	// ------------- Required header parameter "User-Agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("User-Agent")]; found {
		var UserAgent string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for User-Agent, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, valueList[0], &UserAgent)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter User-Agent: %s", err))
		}

		params.UserAgent = UserAgent
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter User-Agent is required, but not found"))
	}
	// ------------- Required header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = AcceptLanguage
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Accept-Language is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PlayMediaIntentHandling(ctx, params)
	return err
}

// UpdateMediaAffinityIntentHandling converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateMediaAffinityIntentHandling(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateMediaAffinityIntentHandlingParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-applecloudextension-session-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-applecloudextension-session-id")]; found {
		var XApplecloudextensionSessionId string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-applecloudextension-session-id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-applecloudextension-session-id", runtime.ParamLocationHeader, valueList[0], &XApplecloudextensionSessionId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-applecloudextension-session-id: %s", err))
		}

		params.XApplecloudextensionSessionId = XApplecloudextensionSessionId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-applecloudextension-session-id is required, but not found"))
	}
	// ------------- Optional header parameter "x-applecloudextension-retry-count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-applecloudextension-retry-count")]; found {
		var XApplecloudextensionRetryCount int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-applecloudextension-retry-count, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-applecloudextension-retry-count", runtime.ParamLocationHeader, valueList[0], &XApplecloudextensionRetryCount)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-applecloudextension-retry-count: %s", err))
		}

		params.XApplecloudextensionRetryCount = &XApplecloudextensionRetryCount
	}
	// ------------- Required header parameter "Request-Timeout" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Timeout")]; found {
		var RequestTimeout int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Request-Timeout, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Request-Timeout", runtime.ParamLocationHeader, valueList[0], &RequestTimeout)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Request-Timeout: %s", err))
		}

		params.RequestTimeout = RequestTimeout
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Request-Timeout is required, but not found"))
	}
	// ------------- Required header parameter "User-Agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("User-Agent")]; found {
		var UserAgent string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for User-Agent, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, valueList[0], &UserAgent)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter User-Agent: %s", err))
		}

		params.UserAgent = UserAgent
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter User-Agent is required, but not found"))
	}
	// ------------- Required header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = AcceptLanguage
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Accept-Language is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateMediaAffinityIntentHandling(ctx, params)
	return err
}

// PlayMediaOnQueue converts echo context to params.
func (w *ServerInterfaceWrapper) PlayMediaOnQueue(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PlayMediaOnQueueParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-applecloudextension-session-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-applecloudextension-session-id")]; found {
		var XApplecloudextensionSessionId string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-applecloudextension-session-id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-applecloudextension-session-id", runtime.ParamLocationHeader, valueList[0], &XApplecloudextensionSessionId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-applecloudextension-session-id: %s", err))
		}

		params.XApplecloudextensionSessionId = XApplecloudextensionSessionId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-applecloudextension-session-id is required, but not found"))
	}
	// ------------- Optional header parameter "x-applecloudextension-retry-count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-applecloudextension-retry-count")]; found {
		var XApplecloudextensionRetryCount int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-applecloudextension-retry-count, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-applecloudextension-retry-count", runtime.ParamLocationHeader, valueList[0], &XApplecloudextensionRetryCount)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-applecloudextension-retry-count: %s", err))
		}

		params.XApplecloudextensionRetryCount = &XApplecloudextensionRetryCount
	}
	// ------------- Required header parameter "User-Agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("User-Agent")]; found {
		var UserAgent string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for User-Agent, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, valueList[0], &UserAgent)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter User-Agent: %s", err))
		}

		params.UserAgent = UserAgent
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter User-Agent is required, but not found"))
	}
	// ------------- Required header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = AcceptLanguage
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Accept-Language is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PlayMediaOnQueue(ctx, params)
	return err
}

// UpdateActivityOnQueue converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateActivityOnQueue(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateActivityOnQueueParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-applecloudextension-session-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-applecloudextension-session-id")]; found {
		var XApplecloudextensionSessionId string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-applecloudextension-session-id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-applecloudextension-session-id", runtime.ParamLocationHeader, valueList[0], &XApplecloudextensionSessionId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-applecloudextension-session-id: %s", err))
		}

		params.XApplecloudextensionSessionId = XApplecloudextensionSessionId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-applecloudextension-session-id is required, but not found"))
	}
	// ------------- Optional header parameter "x-applecloudextension-retry-count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-applecloudextension-retry-count")]; found {
		var XApplecloudextensionRetryCount int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-applecloudextension-retry-count, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-applecloudextension-retry-count", runtime.ParamLocationHeader, valueList[0], &XApplecloudextensionRetryCount)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-applecloudextension-retry-count: %s", err))
		}

		params.XApplecloudextensionRetryCount = &XApplecloudextensionRetryCount
	}
	// ------------- Required header parameter "User-Agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("User-Agent")]; found {
		var UserAgent string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for User-Agent, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, valueList[0], &UserAgent)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter User-Agent: %s", err))
		}

		params.UserAgent = UserAgent
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter User-Agent is required, but not found"))
	}
	// ------------- Required header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept-Language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, valueList[0], &AcceptLanguage)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept-Language: %s", err))
		}

		params.AcceptLanguage = AcceptLanguage
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Accept-Language is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateActivityOnQueue(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/configuration", wrapper.ExtensionConfiguration)
	router.POST(baseURL+"/intent/addMedia", wrapper.AddMediaIntentHandling)
	router.POST(baseURL+"/intent/playMedia", wrapper.PlayMediaIntentHandling)
	router.POST(baseURL+"/intent/updateMediaAffinity", wrapper.UpdateMediaAffinityIntentHandling)
	router.POST(baseURL+"/queues/playMedia", wrapper.PlayMediaOnQueue)
	router.POST(baseURL+"/queues/updateActivity", wrapper.UpdateActivityOnQueue)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

